## 变量作用域
- 如果一个用`var`声明的变量在函数体内部申明，则该变量的作用域为整个函数体，在函数体外不可引用该变量
- 不同函数内部的同名变量互相独立，互不影响
- 嵌套的函数当中，内部函数可以访问外部函数定义的变量，反过来则不行
- 函数在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量
- 变量提升
    - js函数会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部。但是只是自动提升了变量的声明，但不会提升变量的赋值。
    ```javascript
    function foo() {
        var x = 'Hello, ' + y;
        console.log(x);     //Hello, undefined
        var y = 'Bob';
    }
    foo();
    ```
    - 在函数内部定义变量时，要严格遵守“在函数内部首先申明所有变量”这一规则
- 全局作用域
    - 不在任何函数内定义的变量就具有全局作用域，全局作用域的变量实际上被绑定到`window`的一个属性
    - JS只有一个全局作用域。任何变量（函数也视为变量），如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报ReferenceError错误
- 命名空间
    - 全局变量会绑定在`window`上，不同的js文件如果用了相同的全局变量或者相同名字的顶层函数，会造成命名冲突，而且很难被发现
    - 减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中
    ```javascript
    // 唯一的全局变量MYAPP:
    var MYAPP = {};
    // 其他变量:
    MYAPP.name = 'myapp';
    MYAPP.version = 1.0;
    // 其他函数:
    MYAPP.foo = function () {
        return 'foo';
    };
    ```
- 局部作用域
    - 在`for`循环等语句块中是无法定义具有局部作用域的变量的
    - 为了解决块级作用域，ES6引入了新的关键字`let`，用`let`替代`var`可以申明一个块级作用域的变量
    ```javascript
    function foo() {
        var sum = 0;
        for (let i=0; i<100; i++) {     //如果用var定义,，下面的i会变成101
            sum += i;
        }
        i += 1; // SyntaxError
    }
    ```
- 常量
    - `var`和`let`定义的都是变量
    - `const`可以定义常量
    - `const`和`let`都具有块级作用域
```javascript
const PI = 3.14;
PI = 3; // 某些浏览器不报错，但是无效果！
PI; // 3.14
```