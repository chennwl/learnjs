<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>组件Component</title>
	<script src="../vue.js"></script>
</head>
<body>
	<fieldset>
		<legend>使用组件</legend>
		<div id="app">
			<!--全局组件-->
			<global-component></global-component>
			<private-component></private-component>
		</div>
		<div id="example-1">
			<global-component></global-component>
			<private-component></private-component>
		</div>
	</fieldset>

	<fieldset>
		<legend>data必须是函数</legend>
		<div id="example-2">
		  	<simple-counter></simple-counter>
		  	<simple-counter></simple-counter>
		  	<simple-counter></simple-counter>
		</div>
	</fieldset>

	<fieldset>
		<legend>prop</legend>
		<div id="prop-example-1">
			<h3>使用Prop传递数据</h3>
			<!-- 父组件的数据 mess 通过prop才能下发到子组件 message 中 -->
			<!-- 不用bind绑定就变成字符串mess了 -->
			<child :message="mess"></child>
		</div>

		<div id="prop-example-2">
			<h3>动态Prop</h3>
			<input type="text" v-model="parentMsg" name="" />
			<br />
			<!-- prop应该变为短横线分隔式命名 -->
			<child :child-msg="parentMsg"></child>
			<!-- 把一个对象的所有属性作为 prop 进行传递，使用不带任何参数的 v-bind -->
			<todo-item v-bind="todo"></todo-item>
			<!--
				==> 等价于
			-->
			<todo-item
			  v-bind:text="todo.text"
			  v-bind:is-complete="todo.isComplete"
			></todo-item>
		</div>
		<script type="text/javascript">
			new Vue({
				el: '#prop-example-2',
				data: {
					parentMsg: 'Message is Parent',
					todo: {
						text: 'Learn Vue',
						isComplete: false
					}
				},
				components: {
					child: {
						props: ['childMsg'], //驼峰式命名的prop
						template: '<span>{{ childMsg }}</span>'
					},
					todoItem: {
						props: ['text','isComplete'],
						template: '<div>{{ text + " " + isComplete}}</div>'
					}
				}
			})
		</script>

		<h3>Prop验证：为组件的prop指定验证规则</h3>
		<div id="prop-example-3">
			<!-- 不加v-bind是字面量语法 -->
			<example prop-C="name"></example>
		</div>
		<script>
			//Prop验证
			Vue.component('example', {
			  props: {
			    // 基础类型检测 (`null` 指允许任何类型)
			    propA: Number,
			    // 可能是多种类型
			    propB: [String, Number],
			    // 必传且是字符串
			    propC: {
			      type: String,
			      required: true
			    },
			    // 数值且有默认值
			    propD: {
			      type: Number,
			      default: 100
			    },
			    // 数组/对象的默认值应当由一个工厂函数返回
			    propE: {
			      type: Object,
			      default: function () {
			        return { message: 'hello' }
			      }
			    },
			    // 自定义验证函数
			    propF: {
			      validator: function (value) {
			        return value > 10
			      }
			    }
			  },
			  template: '<div>{{propC + propD}}</div>'
			});

			new Vue({
				el: '#prop-example-3'
			})
		</script>
	</fieldset>

	<fieldset>
		<legend>自定义事件(子组件跟父组件通信)</legend>
		<div></div>
	</fieldset>



	<script type="text/javascript">
		//全局注册
		Vue.component('global-component', {
			template: '<div>This is a global-component</div>'
		});

		//局部组件
		var vm = new Vue({
			el: '#app',
			components: {
				//局部组件，仅在该父作用域模板中可用
				'private-component': {
					template: '<p>局部组件</p>'
				}
			}
		});

		//example－1用来验证全局组件和局部组件
		var example1 = new Vue({
			el: '#example-1'
		});

		//在组件里面data必须是函数并返回一个对象
		var data = { counter: 0 }

		Vue.component('simple-counter', {
		  template: '<button v-on:click="counter += 1">{{ counter }}</button>',
		  // 技术上 data 的确是一个函数了，因此 Vue 不会警告，
		  // 但是这里却给每个组件实例返回了同一个对象的引用
		  // 三组实例共享了同一个data对象
		  data: function () {
		    // return data
		    /**
		     *	为每个组件返回全新的数据对象来避免递增一个 counter 会影响所有组件的问题
		     */
		    return {
		    	counter: 0
		    }
		  }
		})

		new Vue({
		  el: '#example-2'
		});
		//

		//子组件要显式地用 props 选项声明它预期的数据
		var propExample1 = new Vue({
			el: '#prop-example-1',
			data: {
				mess: '父组件内容'
			},
			components: {
				child: {
					//声明 props
					props: ['message'],
					template: '<span>{{ message }}</span>'
				}
			}
		})
	</script>
</body>
</html>