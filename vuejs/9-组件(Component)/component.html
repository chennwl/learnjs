<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>组件Component</title>
	<script src="../vue.js"></script>
</head>
<body>
	<fieldset>
		<legend>使用组件</legend>
		<div id="app">
			<!--全局组件-->
			<global-component></global-component>
			<private-component></private-component>
		</div>
		<div id="example-1">
			<global-component></global-component>
			<private-component></private-component>
		</div>
	</fieldset>

	<fieldset>
		<legend>data必须是函数</legend>
		<div id="example-2">
		  	<simple-counter></simple-counter>
		  	<simple-counter></simple-counter>
		  	<simple-counter></simple-counter>
		</div>
	</fieldset>

	<fieldset>
		<legend>prop</legend>
		<div id="prop-example-1">
			<h3>使用Prop传递数据</h3>
			<!-- 父组件的数据 mess 通过prop才能下发到子组件 message 中 -->
			<!-- 不用bind绑定就变成字符串mess了 -->
			<child :message="mess"></child>
		</div>

		<div id="prop-example-2">
			<h3>动态Prop</h3>
			<input type="text" v-model="parentMsg" name="" />
			<br />
			<!-- prop应该变为短横线分隔式命名 -->
			<child :child-msg="parentMsg"></child>
			<!-- 把一个对象的所有属性作为 prop 进行传递，使用不带任何参数的 v-bind -->
			<todo-item v-bind="todo"></todo-item>
			<!--
				==> 等价于
			-->
			<todo-item
			  v-bind:text="todo.text"
			  v-bind:is-complete="todo.isComplete"
			></todo-item>
		</div>
		<script type="text/javascript">
			new Vue({
				el: '#prop-example-2',
				data: {
					parentMsg: 'Message is Parent',
					todo: {
						text: 'Learn Vue',
						isComplete: false
					}
				},
				components: {
					child: {
						props: ['childMsg'], //驼峰式命名的prop
						template: '<span>{{ childMsg }}</span>'
					},
					todoItem: {
						props: ['text','isComplete'],
						template: '<div>{{ text + " " + isComplete}}</div>'
					}
				}
			})
		</script>

		<h3>Prop验证：为组件的prop指定验证规则</h3>
		<div id="prop-example-3">
			<!-- 不加v-bind是字面量语法 -->
			<example prop-C="name"></example>
		</div>
		<script>
			//Prop验证
			Vue.component('example', {
			  props: {
			    // 基础类型检测 (`null` 指允许任何类型)
			    propA: Number,
			    // 可能是多种类型
			    propB: [String, Number],
			    // 必传且是字符串
			    propC: {
			      type: String,
			      required: true
			    },
			    // 数值且有默认值
			    propD: {
			      type: Number,
			      default: 100
			    },
			    // 数组/对象的默认值应当由一个工厂函数返回
			    propE: {
			      type: Object,
			      default: function () {
			        return { message: 'hello' }
			      }
			    },
			    // 自定义验证函数
			    propF: {
			      validator: function (value) {
			        return value > 10
			      }
			    }
			  },
			  template: '<div>{{propC + propD}}</div>'
			});

			new Vue({
				el: '#prop-example-3'
			})
		</script>
	</fieldset>

	<fieldset>
		<legend>自定义事件(子组件跟父组件通信)</legend>
		<div id="counter-event-example">
			<p>{{ total }}</p>
			<!-- 在模板里直接用 v-on 绑定子组件释放的事件 -->
			<button-center v-on:increment="incrementTotal"></button-center>
			<button-center v-on:increment="incrementTotal"></button-center>
		</div>
		<script type="text/javascript">
			Vue.component('button-center', {
				template: '<button v-on:click="incrementCounter">{{ counter }}</button>',
				data: function(){
					//data必须是函数，返回的要是一个对象，不然定义的变量会指向同一个内存
					return {
						counter: 0
					}
				},
				methods: {
					incrementCounter: function(){
						this.counter += 1;
						//子组件$emit触发increment操作，eventName要加冒号，不然就是变量了
						this.$emit('increment');
					}
				}
			});

			new Vue({
				el: '#counter-event-example',
				data: {
					total: 0
				},
				methods: {
					incrementTotal: function(){
						this.total += 1;
					}
				}
			})
		</script>

		<h3>如何使用载荷(payload)数据的示例：</h3>
		<div id="message-event-example" class="demo">
			<p v-for="msg in messages">{{ msg }}</p>
  			<button-message v-on:message="handleMessage"></button-message>
		</div>
		<script>
			Vue.component('button-message', {
				template: `<div><input type="text" v-model="message" />
					<button v-on:click="handleSendMessage">Send</button></div>`,
				data: function(){
					return {
						message: 'test message'
					}
				},
				methods: {
					handleSendMessage: function(){
						this.$emit('message', {
							message: this.message,
							name: 'text'
						})
					}
				}
			});

			new Vue({
				el: '#message-event-example',
				data: {
					messages: []
				},
				methods: {
					handleMessage: function(payload){
						console.log(payload); //payload：{message: this.message,name: 'text'}}
						this.messages.push(payload.message);
					}
				}
			})
		</script>

		<h3>使用自定义事件的表单输入组件</h3>
		<div id="currency-event-example">
			<currency-input v-model="price"></currency-input>
		</div>
		<script>
			Vue.component('currency-input', {
				template: '\
				    <span>\
				      $\
				      <input\
				        ref="input"\
				        v-bind:value="value"\
				        v-on:input="updateValue($event.target.value)"\
				      >\
				    </span>\
				  ',
				  props: ['value'],
				  methods: {
				    // 不是直接更新值，而是使用此方法来对输入值进行格式化和位数限制
				    updateValue: function (value) {
				      var formattedValue = value
				        // 删除两侧的空格符
				        .trim()
				        // 保留 2 位小数
				        .slice(
				          0,
				          value.indexOf('.') === -1
				            ? value.length
				            : value.indexOf('.') + 3
				        )
				      // 如果值尚不合规，则手动覆盖为合规的值
				      if (formattedValue !== value) {
				        this.$refs.input.value = formattedValue
				      }
				      // 通过 input 事件带出数值
				      this.$emit('input', Number(formattedValue))
				    }
				  }
			});

			new Vue({
				el: '#currency-event-example',
				data: {
					price: ''
				}
			})
		</script>
	</fieldset>



	<script type="text/javascript">
		//全局注册
		Vue.component('global-component', {
			template: '<div>This is a global-component</div>'
		});

		//局部组件
		var vm = new Vue({
			el: '#app',
			components: {
				//局部组件，仅在该父作用域模板中可用
				'private-component': {
					template: '<p>局部组件</p>'
				}
			}
		});

		//example－1用来验证全局组件和局部组件
		var example1 = new Vue({
			el: '#example-1'
		});

		//在组件里面data必须是函数并返回一个对象
		var data = { counter: 0 }

		Vue.component('simple-counter', {
		  template: '<button v-on:click="counter += 1">{{ counter }}</button>',
		  // 技术上 data 的确是一个函数了，因此 Vue 不会警告，
		  // 但是这里却给每个组件实例返回了同一个对象的引用
		  // 三组实例共享了同一个data对象
		  data: function () {
		    // return data
		    /**
		     *	为每个组件返回全新的数据对象来避免递增一个 counter 会影响所有组件的问题
		     */
		    return {
		    	counter: 0
		    }
		  }
		})

		new Vue({
		  el: '#example-2'
		});
		//

		//子组件要显式地用 props 选项声明它预期的数据
		var propExample1 = new Vue({
			el: '#prop-example-1',
			data: {
				mess: '父组件内容'
			},
			components: {
				child: {
					//声明 props
					props: ['message'],
					template: '<span>{{ message }}</span>'
				}
			}
		})
	</script>
</body>
</html>